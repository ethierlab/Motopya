class RotaryEncoder2(EventsMixin, CompositeDevice):
    """
    Represents a simple two-pin incremental `rotary encoder`_ device with half-step support.

    These devices typically have three pins labelled "A", "B", and "C". Connect
    A and B directly to two GPIO pins, and C ("common") to one of the ground
    pins on your Pi. Then simply specify the A and B pins as the arguments when
    constructing this class.

    For example, if your encoder's A pin is connected to GPIO 21, and the B
    pin to GPIO 20 (and presumably the C pin to a suitable GND pin), while an
    LED (with a suitable 300Ω resistor) is connected to GPIO 5, the following
    session will result in the brightness of the LED being controlled by
    dialling the rotary encoder back and forth::

        >>> from gpiozero import RotaryEncoder2
        >>> from gpiozero.tools import scaled_half
        >>> rotor = RotaryEncoder2(21, 20)
        >>> led = PWMLED(5)
        >>> led.source = scaled_half(rotor.values)

    :type a: int or str
    :param a:
        The GPIO pin connected to the "A" output of the rotary encoder.

    :type b: int or str
    :param b:
        The GPIO pin connected to the "B" output of the rotary encoder.

    :type bounce_time: float or None
    :param bounce_time:
        If :data:`None` (the default), no software bounce compensation will be
        performed. Otherwise, this is the length of time (in seconds) that the
        component will ignore changes in state after an initial change.

    :type max_steps: int
    :param max_steps:
        The number of steps clockwise the encoder takes to change the
        :attr:`value` from 0 to 1, or counter-clockwise from 0 to -1.
        If this is 0, then the encoder's :attr:`value` never changes, but you
        can still read :attr:`steps` to determine the integer number of steps
        the encoder has moved clockwise or counter clockwise.

    :type threshold_steps: tuple of int
    :param threshold_steps:
        A (min, max) tuple of steps between which the device will be considered
        "active", inclusive. In other words, when :attr:`steps` is greater than
        or equal to the *min* value, and less than or equal the *max* value,
        the :attr:`active` property will be :data:`True` and the appropriate
        events (:attr:`when_activated`, :attr:`when_deactivated`) will be
        fired. Defaults to (0, 0).

    :type wrap: bool
    :param wrap:
        If :data:`True` and *max_steps* is non-zero, when the :attr:`steps`
        reaches positive or negative *max_steps* it wraps around by negation.
        Defaults to :data:`False`.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _rotary encoder: https://en.wikipedia.org/wiki/Rotary_encoder
    """
    # The rotary encoder's two pins move through the following sequence when
    # the encoder is rotated one step clockwise:
    #
    #   ────┐     ┌─────┐     ┌────────
    #    _  │     │     │     │          counter        ┌───┐
    #    A  │     │     │     │         clockwise  ┌─── │ 0 │ ───┐  clockwise
    #       └─────┘     └─────┘           (CCW)    │    └───┘    │    (CW)
    #       :     :     :     :             │    ┌───┐         ┌───┐    │
    #   ───────┐  :  ┌─────┐  :  ┌─────     ▾    │ 1 │         │ 2 │    ▾
    #    _  :  │  :  │  :  │  :  │               └───┘         └───┘
    #    B  :  │  :  │  :  │  :  │                 │    ┌───┐    │
    #       :  └─────┘  :  └─────┘                 └─── │ 3 │ ───┘
    #       :  :  :  :  :  :  :  :                      └───┘
    #    0  2  3  1  0  2  3  1  0
    #
    # Treating the A pin as a "high" bit, and the B pin as a "low" bit, this
    # means that the pins return the sequence 0, 2, 3, 1 for each step that the
    # encoder takes clockwise. Conversely, the pins return the sequence 0, 1,
    # 3, 2 for each step counter-clockwise.
    #
    # We can treat these values as edges to take in a simple state machine,
    # which is represented in the dictionary below:

    FULL_STEP_TRANSITIONS = {
        'cw3':  ['+1',   'cw3',  'idle', 'cw2'],
        'cw2':  ['idle', 'cw3',  'cw1',  'cw2'],
        'cw1':  ['idle', 'cw3',  'cw1',  'cw2'],
        'idle': ['idle', 'ccw1', 'cw1',  'idle'],
        'ccw1': ['idle', 'ccw1', 'ccw3', 'ccw2'],
        'ccw2': ['idle', 'ccw1', 'ccw3', 'ccw2'],
        'ccw3': ['-1',   'idle', 'ccw3', 'ccw2'],
        
    }
    
    QUARTER_STEP_TRANSITIONS = {
        '0': ['0', '-1', '+1',  'x'],
        '1': ['+1', '0', 'x', '-1'],
        '2': ['-1', 'x', '0', '+1'],
        '3': ['x',   '+1', '-1', '0'],
        
    }


    def __init__(self, a, b, *, bounce_time=None, max_steps=16,
                 threshold_steps=(0, 0), wrap=False, pin_factory=None, half_step=False):
        min_thresh, max_thresh = threshold_steps
        if max_thresh < min_thresh:
            raise ValueError('maximum threshold cannot be less than minimum')
        self._steps = 0
        self._max_steps = int(max_steps)
        self._threshold = (int(min_thresh), int(max_thresh))
        self._wrap = bool(wrap)
        self._state = 'idle'
        self._edge = 0
        self._last_edge = 0
        self._when_rotated = None
        self._when_rotated_cw = None
        self._when_rotated_ccw = None
        self._rotate_event = Event()
        self._rotate_cw_event = Event()
        self._rotate_ccw_event = Event()
        self._half_step = bool(half_step)
        super().__init__(
            a=InputDevice(a, pull_up=True, pin_factory=pin_factory),
            b=InputDevice(b, pull_up=True, pin_factory=pin_factory),
            _order=('a', 'b'), pin_factory=pin_factory)
        self.a.pin.bounce_time = bounce_time
        self.b.pin.bounce_time = bounce_time
        self.a.pin.edges = 'both'
        self.b.pin.edges = 'both'
        self.a.pin.when_changed = self._a_changed
        self.b.pin.when_changed = self._b_changed
        # Call _fire_events once to set initial state of events
        self._fire_events(self.pin_factory.ticks(), self.is_active)

    def __repr__(self):
        try:
            self._check_open()
            return (
                f"<gpiozero.{self.__class__.__name__} object on pins "
                f"{self.a.pin!r} and {self.b.pin!r}>")
        except DeviceClosed:
            return super().__repr__()

    def _a_changed(self, ticks, state):
        edge = (self.a._state_to_value(state) << 1) | (self._edge & 0x1)
        if self._half_step :
            self._change_state2(ticks, edge)
        else:
            self._change_state(ticks, edge)

    def _b_changed(self, ticks, state):
        edge = (self._edge & 0x2) | self.b._state_to_value(state)
        if self._half_step :
            self._change_state2(ticks, edge)
        else:
            self._change_state(ticks, edge)

    def _change_state(self, ticks, edge):
        self._edge = edge
        transitions = RotaryEncoder2.FULL_STEP_TRANSITIONS
        new_state = transitions[self._state][edge]
        # print(self._state+"+"+str(self._edge)+"+"+new_state)
        if new_state == '+1':
            self._steps = (
                self._steps + 1
                if not self._max_steps or self._steps < self._max_steps else
                -self._max_steps if self._wrap else self._max_steps
            )
            self._rotate_cw_event.set()
            self._fire_rotated_cw()
            self._rotate_cw_event.clear()
            self._state = 'idle'
        elif new_state == '-1':
            self._steps = (
                self._steps - 1
                if not self._max_steps or self._steps > -self._max_steps else
                self._max_steps if self._wrap else -self._max_steps
            )
            self._rotate_ccw_event.set()
            self._fire_rotated_ccw()
            self._rotate_ccw_event.clear()   
            self._state = 'idle'        
        else:
            self._state = new_state
            return
        self._rotate_event.set()
        self._fire_rotated()
        self._rotate_event.clear()
        self._fire_events(ticks, self.is_active)

    def _change_state2(self, ticks, edge):
        self._edge = edge
        transitions = RotaryEncoder2.QUARTER_STEP_TRANSITIONS
        new_state = transitions[str(self._last_edge)][edge]
        # print(str(self._last_edge)+"+"+str(self._edge)+"+"+new_state)
        if new_state == '+1':
            self._steps = (
                self._steps + 0.25
                if not self._max_steps or self._steps < self._max_steps else
                -self._max_steps if self._wrap else self._max_steps
            )
            self._rotate_cw_event.set()
            self._fire_rotated_cw()
            self._rotate_cw_event.clear()
            self._state = 'idle'
        elif new_state == '-1':
            self._steps = (
                self._steps - 0.25
                if not self._max_steps or self._steps > -self._max_steps else
                self._max_steps if self._wrap else -self._max_steps
            )
            self._rotate_ccw_event.set()
            self._fire_rotated_ccw()
            self._rotate_ccw_event.clear()   
            self._state = 'idle'
        
        else:
            self._state = new_state
            return
        self._last_edge=self._edge
        self._rotate_event.set()
        self._fire_rotated()
        self._rotate_event.clear()
        self._fire_events(ticks, self.is_active)        

    def wait_for_rotate(self, timeout=None):
        """
        Pause the script until the encoder is rotated at least one step in
        either direction, or the timeout is reached.

        :type timeout: float or None
        :param timeout:
            Number of seconds to wait before proceeding. If this is
            :data:`None` (the default), then wait indefinitely until the
            encoder is rotated.
        """
        return self._rotate_event.wait(timeout)

    def wait_for_rotate_clockwise(self, timeout=None):
        """
        Pause the script until the encoder is rotated at least one step
        clockwise, or the timeout is reached.

        :type timeout: float or None
        :param timeout:
            Number of seconds to wait before proceeding. If this is
            :data:`None` (the default), then wait indefinitely until the
            encoder is rotated clockwise.
        """
        return self._rotate_cw_event.wait(timeout)

    def wait_for_rotate_counter_clockwise(self, timeout=None):
        """
        Pause the script until the encoder is rotated at least one step
        counter-clockwise, or the timeout is reached.

        :type timeout: float or None
        :param timeout:
            Number of seconds to wait before proceeding. If this is
            :data:`None` (the default), then wait indefinitely until the
            encoder is rotated counter-clockwise.
        """
        return self._rotate_ccw_event.wait(timeout)

    when_rotated = event(
        """
        The function to be run when the encoder is rotated in either direction.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that activated will be passed
        as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """)

    when_rotated_clockwise = event(
        """
        The function to be run when the encoder is rotated clockwise.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that activated will be passed
        as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """)

    when_rotated_counter_clockwise = event(
        """
        The function to be run when the encoder is rotated counter-clockwise.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that activated will be passed
        as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """)

    @property
    def steps(self):
        """
        The "steps" value of the encoder starts at 0. It increments by one for
        every step the encoder is rotated clockwise, and decrements by one for
        every step it is rotated counter-clockwise. The steps value is
        limited by :attr:`max_steps`. It will not advance beyond positive or
        negative :attr:`max_steps`, unless :attr:`wrap` is :data:`True` in
        which case it will roll around by negation. If :attr:`max_steps` is
        zero then steps are not limited at all, and will increase infinitely
        in either direction, but :attr:`value` will return a constant zero.

        Note that, in contrast to most other input devices, because the rotary
        encoder has no absolute position the :attr:`steps` attribute (and
        :attr:`value` by corollary) is writable.
        """
        return self._steps

    def _fire_rotated(self):
        if self.when_rotated:
            self.when_rotated()

    def _fire_rotated_cw(self):
        if self.when_rotated_clockwise:
            self.when_rotated_clockwise()

    def _fire_rotated_ccw(self):
        if self.when_rotated_counter_clockwise:
            self.when_rotated_counter_clockwise()

    @steps.setter
    def steps(self, value):
        value = int(value)
        if self._max_steps:
            value = max(-self._max_steps, min(self._max_steps, value))
        self._steps = value

    @property
    def value(self):
        """
        Represents the value of the rotary encoder as a value between -1 and 1.
        The value is calculated by dividing the value of :attr:`steps` into the
        range from negative :attr:`max_steps` to positive :attr:`max_steps`.

        Note that, in contrast to most other input devices, because the rotary
        encoder has no absolute position the :attr:`value` attribute is
        writable.
        """
        try:
            return self._steps / self._max_steps
        except ZeroDivisionError:
            return 0

    @value.setter
    def value(self, value):
        self._steps = int(max(-0.5, min(0.5, float(value))) * self._max_steps)

    @property
    def is_active(self):
        return self._threshold[0] <= self._steps <= self._threshold[1]

    @property
    def max_steps(self):
        """
        The number of discrete steps the rotary encoder takes to move
        :attr:`value` from 0 to 1 clockwise, or 0 to -1 counter-clockwise. In
        another sense, this is also the total number of discrete states this
        input can represent.
        """
        return self._max_steps

    @property
    def threshold_steps(self):
        """
        The mininum and maximum number of steps between which :attr:`is_active`
        will return :data:`True`. Defaults to (0, 0).
        """
        return self._threshold

    @property
    def wrap(self):
        """
        If :data:`True`, when :attr:`value` reaches its limit (-1 or 1), it
        "wraps around" to the opposite limit. When :data:`False`, the value
        (and the corresponding :attr:`steps` attribute) simply don't advance
        beyond their limits.
        """
        return self._wrap